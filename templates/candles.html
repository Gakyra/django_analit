{% extends "base.html" %}
{% block title %}–°–≤—ñ—á–∫–∏ ‚Äî {{ asset_name }}{% endblock %}
{% block content %}
<div class="glass p-4">
    <h2 class="text-center mb-4">üïØÔ∏è –°–≤—ñ—á–∫–æ–≤–∏–π –≥—Ä–∞—Ñ—ñ–∫: {{ asset_name }}</h2>

    <form method="get" class="row g-3 mb-4">
        <div class="col-md-4">
            <label class="form-label">–ê–∫—Ç–∏–≤</label>
            <select name="asset" class="form-select">
                {% for key, name in assets.items %}
                    <option value="{{ key }}" {% if key == asset_id %}selected{% endif %}>{{ name }}</option>
                {% endfor %}
            </select>
        </div>
        <div class="col-md-4">
            <label class="form-label">–¢–∞–π–º—Ñ—Ä–µ–π–º</label>
            <select name="interval" class="form-select">
                {% for tf in timeframes %}
                    <option value="{{ tf }}" {% if tf == interval %}selected{% endif %}>{{ tf }}</option>
                {% endfor %}
            </select>
        </div>
        <div class="col-md-4 d-flex align-items-end">
            <button type="submit" class="btn btn-success w-100">–û–Ω–æ–≤–∏—Ç–∏</button>
        </div>
    </form>

    <div id="tv-chart"
         style="height: 500px;"
         data-symbol="{{ binance_symbol }}"
         data-interval="{{ interval }}"></div>

    <div class="mt-4">
        <h5>üßæ –ñ—É—Ä–Ω–∞–ª –ø–æ–¥—ñ–π</h5>
        <pre id="log-output" style="background:#111;color:#ccc;padding:1rem;height:200px;overflow:auto;border-radius:8px;font-size:0.9rem;"></pre>
    </div>
</div>

<script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
<script>
document.addEventListener("DOMContentLoaded", function () {
    const chartEl = document.getElementById("tv-chart");
    const logOutput = document.getElementById("log-output");

    function logMessage(msg, type = "info") {
        if (!logOutput) return;
        const prefix = {
            info: "‚ÑπÔ∏è",
            success: "‚úÖ",
            warn: "‚ö†Ô∏è",
            error: "‚ùå",
            data: "üì¶"
        }[type] || "";
        const line = `[${new Date().toLocaleTimeString()}] ${prefix} ${msg}`;
        logOutput.textContent += line + "\n";
        logOutput.scrollTop = logOutput.scrollHeight;
        console[type === "error" ? "error" : "log"](line);
    }

    const symbol = chartEl.dataset.symbol;
    const interval = chartEl.dataset.interval;
    const wsUrl = `wss://stream.binance.com:9443/ws/${symbol}@kline_${interval}`;
    logMessage(`üîó –ü—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –¥–æ WebSocket: ${wsUrl}`, "info");

    const chart = LightweightCharts.createChart(chartEl, {
        layout: { background: { color: '#121212' }, textColor: '#ccc' },
        grid: { vertLines: { color: '#333' }, horzLines: { color: '#333' } },
        timeScale: { timeVisible: true, secondsVisible: true },
        priceScale: { borderColor: '#555' }
    });

    const candleSeries = chart.addCandlestickSeries({
        upColor: '#00ff99',
        downColor: '#ff4444',
        wickUpColor: '#00ff99',
        wickDownColor: '#ff4444'
    });

    const candles = [];

    fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol.toUpperCase()}&interval=${interval}&limit=100`)
        .then(res => res.json())
        .then(data => {
            const initialCandles = data.map(k => ({
                time: Math.floor(k[0] / 1000),
                open: parseFloat(k[1]),
                high: parseFloat(k[2]),
                low: parseFloat(k[3]),
                close: parseFloat(k[4])
            }));
            candles.push(...initialCandles);
            if (candles.length > 0) {
                candleSeries.setData(candles);
                logMessage(`üìä –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–æ ${candles.length} —Å–≤—ñ—á–æ–∫ –∑ REST API`, "success");
            } else {
                logMessage("‚ö†Ô∏è REST API –ø–æ–≤–µ—Ä–Ω—É–ª–æ –ø–æ—Ä–æ–∂–Ω—ñ –¥–∞–Ω—ñ", "warn");
            }
        })
        .catch(err => logMessage("‚ùå –ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è REST API: " + err.message, "error"));

    const socket = new WebSocket(wsUrl);
    socket.onopen = () => logMessage("‚úÖ WebSocket –∑'—î–¥–Ω–∞–Ω–æ", "success");
    socket.onerror = (e) => logMessage("‚ùå –ü–æ–º–∏–ª–∫–∞ WebSocket: " + e.message, "error");
    socket.onclose = (e) => logMessage("‚ö†Ô∏è WebSocket –∑–∞–∫—Ä–∏—Ç–æ", "warn");

    socket.onmessage = function (event) {
        try {
            const data = JSON.parse(event.data);
            if (!data.k) {
                logMessage("‚ö†Ô∏è –ù–µ–≤—ñ–¥–æ–º–∏–π —Ñ–æ—Ä–º–∞—Ç –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è", "warn");
                return;
            }

            const k = data.k;
            const candle = {
                time: Math.floor(k.t / 1000),
                open: parseFloat(k.o),
                high: parseFloat(k.h),
                low: parseFloat(k.l),
                close: parseFloat(k.c)
            };

            const last = candles[candles.length - 1];
            if (last && last.time === candle.time) {
                candles[candles.length - 1] = candle;
            } else {
                candles.push(candle);
            }

            const recent = candles.slice(-100);
            candleSeries.setData(recent);
            logMessage(`üì¶ –û–Ω–æ–≤–ª–µ–Ω–æ —Å–≤—ñ—á–∫—É: ${candle.close}`, "data");
        } catch (err) {
            logMessage("‚ùå –ü–æ–º–∏–ª–∫–∞ –æ–±—Ä–æ–±–∫–∏ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è: " + err.message, "error");
        }
    };
});
</script>
{% endblock %}
